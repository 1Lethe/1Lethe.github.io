<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在编译优化角度分析volatile关键字-一个有趣的案例</title>
    <link href="/2025/09/01/%E5%9C%A8%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97-%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <url>/2025/09/01/%E5%9C%A8%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97-%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>和学弟讨论volatile关键字时提到的一个有意思的案例,汇编视角分析编译优化的不同影响</p><span id="more"></span><p>代码示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> _end;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = &amp;_end;<br>  *p = <span class="hljs-number">0x0</span>;<br>  <span class="hljs-keyword">while</span>(*p != <span class="hljs-number">0xff</span>);<br>  *p = <span class="hljs-number">0x33</span>;<br>  *p = <span class="hljs-number">0x34</span>;<br>  *p = <span class="hljs-number">0x86</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    fun();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="情况1：-p-0x0，无volatile，-O2优化"><a href="#情况1：-p-0x0，无volatile，-O2优化" class="headerlink" title="情况1：*p &#x3D; 0x0，无volatile，-O2优化"></a>情况1：*p &#x3D; 0x0，无volatile，-O2优化</h2><p>我们使用-O2优化运行代码,不出所料程序卡死在fun()的死循环中。<br>笔者比较熟悉RISC-V汇编，将其交叉编译后进行反汇编。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; riscv64-linux-gnu-gcc -O2 ./fun.c -o fun_rv<br>&gt; riscv64-linux-gnu-objdump -d ./fun_rv | code -<br>Reading from stdin via: /tmp/code-stdin-syc<br></code></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly"><br>00000000000005a0 &lt;main&gt;:<br> 5a0:00002797          auipca5,0x2<br> 5a4:a907b783          lda5,-1392(a5) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> 5a8:00078023          sbzero,0(a5)<br> 5ac:a001                j5ac &lt;main+0xc&gt;<br><br>0000000000000668 &lt;fun&gt;:<br> # 取p的地址<br> 668:00002797          auipca5,0x2<br> 66c:9c87b783          lda5,-1592(a5) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> # 将0x0写入p对应的地址<br> 670:00078023          sbzero,0(a5)<br> # 死循环<br> 674:a001                j674 &lt;fun+0xc&gt;<br></code></pre></td></tr></table></figure><p>编译器认为 while(*p !&#x3D; 0xff); 的结果 可在编译期推导：*p 已经被写死为 0x0，所以循环条件永远为真。<br>可以看到原C代码中<code>while(*p != 0xff)</code>，在汇编中<em>并未读取有关p的值就进行循环</em>，而且优化后的程序<em>只对p对应地址写入了一次，优化掉了while后的三次写入操作</em>。同时在main和fun中没有函数返回（ret）的操作。<br>这就是为什么不加 volatile，编译器会把内存访问假设为“寄存器中的确定值”，导致代码和预期完全不同。</p><h2 id="情况2：-p-0x0，有volatile，-O2优化"><a href="#情况2：-p-0x0，有volatile，-O2优化" class="headerlink" title="情况2：*p &#x3D; 0x0，有volatile，-O2优化"></a>情况2：*p &#x3D; 0x0，有volatile，-O2优化</h2><p>我们将<code>unsigned char *p = &amp;_end;</code>前加上<code>volatile</code>，-02优化，重新编译运行。这一次程序也卡死在fun()的死循环中。<br>我们相同操作进行反汇编。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000000005a0 &lt;main&gt;:<br> # 取p的地址<br> 5a0:00002717          auipca4,0x2<br> 5a4:a9073703          lda4,-1392(a4) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> # 将0x0写入p对应地址<br> 5a8:00070023          sbzero,0(a4)<br> # 将p地址处对应的值写入a4寄存器中，将立即数0xff写入a3寄存器中，并比较两者的值，若不相等即循环读p地址的值比较<br> # 就是这里的while(*p != 0xff);<br> 5ac:0ff00693          lia3,255<br> 5b0:00074783          lbua5,0(a4)<br> 5b4:fed79ee3          bnea5,a3,5b0 &lt;main+0x10&gt;<br> # 将0x33写入p对应地址<br> 5b8:03300793          lia5,51<br> 5bc:00f70023          sba5,0(a4)<br> # 将0x34写入p对应地址<br> 5c0:03400793          lia5,52<br> 5c4:00f70023          sba5,0(a4)<br> # 将0x86写入p对应地址<br> 5c8:f8600793          lia5,-122<br> 5cc:00f70023          sba5,0(a4)<br> # 函数返回值为0（RV32调用约定）<br> 5d0:4501                lia0,0<br> # 函数返回<br> 5d2:8082                ret<br><br># 函数内联导致的重复<br>000000000000068c &lt;fun&gt;:<br> 68c:00002717          auipca4,0x2<br> 690:9a473703          lda4,-1628(a4) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> 694:00070023          sbzero,0(a4)<br> 698:0ff00693          lia3,255<br> 69c:00074783          lbua5,0(a4)<br> 6a0:fed79ee3          bnea5,a3,69c &lt;fun+0x10&gt;<br> 6a4:03300793          lia5,51<br> 6a8:00f70023          sba5,0(a4)<br> 6ac:03400793          lia5,52<br> 6b0:00f70023          sba5,0(a4)<br> 6b4:f8600793          lia5,-122<br> 6b8:00f70023          sba5,0(a4)<br> 6bc:8082                ret<br><br></code></pre></td></tr></table></figure><p>在这里值得注意的是，编译器将fun内联进了main里，做了<strong>函数内联优化</strong>，故在main里进行了fun的操作而不存在函数调用。而同时fun函数符号又存在于ELF文件当中，因此也存在于反汇编结果之中。</p><p>编译器可能会将非易失性变量的值存储在 CPU 寄存器中，以便更快地访问，避免重复从内存读取。对于<code>volatile</code>变量，编译器每次访问时都会强制从内存读取该值。<br>我们可以看到，在C源代码中每一次对p的读取&#x2F;写入操作都没有被编译器优化。</p><h2 id="情况3：-p-0xff，无volatile，-O2优化"><a href="#情况3：-p-0xff，无volatile，-O2优化" class="headerlink" title="情况3：*p &#x3D; 0xff，无volatile，-O2优化"></a>情况3：*p &#x3D; 0xff，无volatile，-O2优化</h2><p>我们将<code>volatile unsigned char *p = &amp;_end;</code>的<code>volatile</code>删去，<code>*p = 0x0;</code>改为<code>*p = 0xff;</code> ，-02优化，重新编译运行。程序现在可以正常退出。<br>我们进行反汇编查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000000005a0 &lt;main&gt;:<br> # 取p的地址<br> 5a0:00002797          auipca5,0x2<br> 5a4:a907b783          lda5,-1392(a5) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> # 将0x86写入p对应地址<br> 5a8:f8600713          lia4,-122<br> 5ac:00e78023          sba4,0(a5)<br> # 函数返回值为0（RV32调用约定）<br> 5b0:4501                lia0,0<br> # 函数返回<br> 5b2:8082                ret<br><br># 函数内联导致的重复<br>000000000000066c &lt;fun&gt;:<br> 66c:00002797          auipca5,0x2<br> 670:9c47b783          lda5,-1596(a5) # 2030 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br> 674:f8600713          lia4,-122<br> 678:00e78023          sba4,0(a5)<br> 67c:8082                ret<br></code></pre></td></tr></table></figure><p>在这里编译器将C源代码中从<code>*p = 0x0;</code>到<code>*p = 0x34;</code>这一段代码全部优化掉了，是因为在这里while循环和对p的多次写入无意义，编译器可以直接优化成最后的<code>*p = 0x86;</code>。(死代码消除与值传播)</p><h2 id="总结：编译优化"><a href="#总结：编译优化" class="headerlink" title="总结：编译优化"></a>总结：编译优化</h2><blockquote><p>我们可以从程序行为的角度来理解编译优化: 如果两个程序在某种意义上”一致”, 就可以用”简单”的替代”复杂”的. 其中, 遵循C语言标准逐条语句执行的行为称为”严格执行”. 以”严格执行”为基准, C语言标准对上文的”一致”作了严谨的定义, 即优化后的程序应满足”程序可观测行为”(C99标准手册5.1.2.3节第6点)的一致性, 具体包括:</p><ol><li>对volatile关键字修饰变量的访问需要严格执行</li><li>程序结束时, 写入文件的数据需要与严格执行时一致</li><li>交互式设备的输入输出(stdio.h)需要与严格执行时一致<br>“可观测行为”刻画的是从外部视角看C程序对外界的影响, 例如, 第2点要求那些没有实时性的外部操作在最后”看起来一致”, 第3点要求那些有实时性的外部操作在执行过程中”看起来一致”.<br>因此, 只要优化后仍然满足程序可观测行为的一致性, 这种优化都是”正确”的. 在这个条件下, 如果优化后的程序变量更少, 或者语句更少, 可以预期程序的性能表现就会更优.</li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>编译优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog入门经验分享</title>
    <link href="/2025/05/08/Verilog%E5%85%A5%E9%97%A8%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/2025/05/08/Verilog%E5%85%A5%E9%97%A8%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>作为一名数字电子技术学生对Verilog HDL语言的学习经验分享</p><span id="more"></span><ol><li><p>数电基础</p><ul><li>逻辑代数基础.</li><li>组合逻辑电路:各种门电路,一些常用电路比如数据选择器,加法器,编码器,译码器,比较器等要十分熟练,要会看电路推导逻辑表达式和真值表,也要熟练逆推.</li><li>时序逻辑电路:双稳态电路,锁存器,触发器,寄存器,一些常用电路比如移位寄存器,计数器等要十分熟练,状态转移图&#x2F;状态机要十分熟练,要会看电路图推波形图,也要熟练逆推.</li></ul></li><li><p>Verilog基础</p><ul><li>Verilog基础语法和关键字<br> <a href="https://www.runoob.com/w3cnote/verilog-tutorial.html">菜鸟教程</a><br> <a href="https://vlab.ustc.edu.cn/guide/doc_verilog.html">中科大Verilog语法入门</a></li><li><strong>重要</strong>:对Verilog HDL要理解其硬件设计的基本概念,即”实例化+连线”,避免使用行为建模方法,避免使用不可综合语句.<br> <a href="https://www.bilibili.com/video/BV1PS4y1s7XW">如何从电路设计角度入门Verilog</a></li></ul><blockquote><p><strong>! 强烈建议初学者不要使用行为建模方式设计电路</strong><br>Verilog一开始并不是为了设计可综合电路而提出的，它的本质是一门基于事件队列模型的电路建模语言。因此，行为建模很容易会让初学者偏离描述电路的初衷: 开发者需要看着电路图，心里想象电路的行为，然后转化成事件队列模型的思考方式，最后再用行为建模方式来描述电路的行为，综合器再来根据这样的描述推导出相应的电路。从这个过程来看，这不仅是没有必要的，而且还很容易引入错误：</p><ul><li>如果开发者心里本身就已经有电路图，直接描述它是最方便的</li><li>如果开发者心里本身就已经有电路图，而开发者对行为建模方式的理解所有偏差，可能会采用了错误的描述方式，从而设计出非预期的电路</li><li>如果开发者心里没有电路图，而是期望通过行为建模方式让综合器生成某种行为的电路，这就已经偏离“描述电路”的本质了。大部分同学非常容易犯这样的错误，把行为建模当作过程式的C语言来写，尝试把任意复杂的行为描述映射到电路，最终综合器只会生成出延迟大，面积大，功耗高的低质量电路</li></ul><p>所以，直到大家掌握“描述电路”的思维而不被行为建模误导之前，我们强烈建议初学者远离行为建模方式，仅通过数据流建模和结构化建模方式直接描述电路。例如，上文关于if和always的说法从某种程度上来说是正确的，但下面的问题可以帮助大家测试自己是否已经掌握了Verilog的本质：</p><ul><li>在硬件描述语言中，“执行”的精确含义是什么？</li><li>是谁在执行Verilog的语句？ 是电路，综合器，还是其它的？</li><li>if的条件满足，就不执行else后的语句，这里的“不执行”又是什么意思？ 和描述电路有什么联系？</li><li>有“并发执行”，又有“顺序执行”，还有“任何一个变量发生变化就立即执行”，以及“在任何情况下都执行”，它们都是如何在设计出来的电路中体现的？<br>如果你无法对这些问题作出明确的回答，我们强烈建议你不要使用行为建模方式。如果你真的想弄懂它们，你需要阅读 Verilog标准手册 。</li></ul><p><strong>真正的描述电路 &#x3D; 实例化 + 连线</strong><br>忘记行为建模方式，就可以很容易回归到描述电路的简单本质。想象一下，你手中有一张电路图纸，如果你需要向其它人描述图纸上的内容，你将会如何描述？ 你一定会说出类似“有一个A元件&#x2F;模块，它的x引脚和另一个B元件&#x2F;模块的y引脚相连”的描述，因为这才是描述电路的最自然的方式。用HDL设计电路，就是在用HDL来描述电路图纸，图纸上有什么，就直接描述什么。所以，用HDL描述电路，无非是做两件事情：</p><ul><li>实例化：在电路板上放一个元件&#x2F;模块，可以是一个门电路，或者是由门电路组成的模块</li><li>连线：用导线将元件&#x2F;模块的引脚正确地连起来<br>大家可以体会一下，数据流建模和结构化建模是如何体现这两件事的，而行为建模又是如何把这两件简单的事情复杂化的。</li></ul></blockquote><ul><li><p>硬件设计思维</p><ul><li>多用Logisim&#x2F;Modelsim画电路&#x2F;写Verilog,跑仿真,看波形</li><li>跟着这款游戏<a href="https://store.steampowered.com/app/1444480/Turing_Complete/">Turing Complete</a>学习也未尝不可</li></ul></li><li><p>多上手实践</p><ul><li>Verilog刷题网站:<a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits</a></li><li><a href="https://nju-projectn.github.io/dlco-lecture-note/exp/01.html">南京大学的数字电路与计算机组成实验</a></li><li>上板练习,练习工程能力:野火&#x2F;小梅哥&#x2F;…的FPGA课程</li></ul></li></ul></li><li><p>进阶:时序约束与优化<br>竞争冒险,建立&#x2F;保持时间,时序约束与时序优化…</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数字电路</tag>
      
      <tag>Verilog</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA3.1-理解穿越时空的旅程</title>
    <link href="/2025/03/28/PA3-1-%E7%90%86%E8%A7%A3%E7%A9%BF%E8%B6%8A%E6%97%B6%E7%A9%BA%E7%9A%84%E6%97%85%E7%A8%8B/"/>
    <url>/2025/03/28/PA3-1-%E7%90%86%E8%A7%A3%E7%A9%BF%E8%B6%8A%E6%97%B6%E7%A9%BA%E7%9A%84%E6%97%85%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>记录笔者在完成PA3.1必答题的个人理解.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><blockquote><p>从yield test调用yield()开始, 到从yield()返回的期间, 这一趟旅程具体经历了什么? 软(AM, yield test)硬(NEMU)件是如何相互协助来完成这趟旅程的? </p></blockquote><h1 id="1-CTE初始化"><a href="#1-CTE初始化" class="headerlink" title="1.CTE初始化"></a>1.CTE初始化</h1><p>设置异常入口与用户异常回调函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">cte_init</span><span class="hljs-params">(Context*(*handler)(Event, Context*))</span> &#123;<br>  <span class="hljs-comment">// 初始化异常入口</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(__am_asm_trap))</span>;<br><br>  <span class="hljs-comment">// 初始化用户回调函数句柄</span><br>  user_handler = handler;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在yield test中调用cte_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">CASE(<span class="hljs-string">&#x27;i&#x27;</span>, hello_intr, IOE, CTE(simple_trap));<br></code></pre></td></tr></table></figure><h1 id="2-进行自陷操作"><a href="#2-进行自陷操作" class="headerlink" title="2.进行自陷操作"></a>2.进行自陷操作</h1><p>在yield test中调用AM的<code>yield()</code>,在AM中调用ecall,在NEMU中:</p><ul><li>将当前PC值保存到mepc寄存器</li><li>在mcause寄存器中设置异常号</li><li>从mtvec寄存器中取出异常入口地址</li><li>跳转到异常入口地址(在AM中是<code>trap.S</code>中的<code>__am_asm_trap</code>函数)</li></ul><h1 id="3-保存上下文"><a href="#3-保存上下文" class="headerlink" title="3.保存上下文"></a>3.保存上下文</h1><p>现在程序跳转到了异常入口<code>trap.S</code>中的<code>__am_asm_trap</code>函数中,先进行保存上下文的操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs riscv">addi sp, sp, -CONTEXT_SIZE<br><br>MAP(REGS, PUSH)<br><br>csrr t0, mcause<br>csrr t1, mstatus<br>csrr t2, mepc<br><br>STORE t0, OFFSET_CAUSE(sp)<br>STORE t1, OFFSET_STATUS(sp)<br>STORE t2, OFFSET_EPC(sp)<br><br>mv a0, sp<br></code></pre></td></tr></table></figure><p>展开为汇编代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs riscv"># 创建栈帧(栈向下生长)<br>80001528:f7410113          addisp,sp,-140<br># 将除$0,sp以外的寄存器入栈<br>8000152c:00112223          swra,4(sp)<br>80001530:00312623          swgp,12(sp)<br>80001534:00412823          swtp,16(sp)<br>80001538:00512a23          swt0,20(sp)<br>8000153c:00612c23          swt1,24(sp)<br>80001540:00712e23          swt2,28(sp)<br>80001544:02812023          sws0,32(sp)<br>80001548:02912223          sws1,36(sp)<br>8000154c:02a12423          swa0,40(sp)<br>80001550:02b12623          swa1,44(sp)<br>80001554:02c12823          swa2,48(sp)<br>80001558:02d12a23          swa3,52(sp)<br>8000155c:02e12c23          swa4,56(sp)<br>80001560:02f12e23          swa5,60(sp)<br>80001564:05012023          swa6,64(sp)<br>80001568:05112223          swa7,68(sp)<br>8000156c:05212423          sws2,72(sp)<br>80001570:05312623          sws3,76(sp)<br>80001574:05412823          sws4,80(sp)<br>80001578:05512a23          sws5,84(sp)<br>8000157c:05612c23          sws6,88(sp)<br>80001580:05712e23          sws7,92(sp)<br>80001584:07812023          sws8,96(sp)<br>80001588:07912223          sws9,100(sp)<br>8000158c:07a12423          sws10,104(sp)<br>80001590:07b12623          sws11,108(sp)<br>80001594:07c12823          swt3,112(sp)<br>80001598:07d12a23          swt4,116(sp)<br>8000159c:07e12c23          swt5,120(sp)<br>800015a0:07f12e23          swt6,124(sp)<br># 读CSR寄存器到t0,t1,t2寄存器(CSR寄存器不能直接入栈,先将其读到寄存器上)<br>800015a4:342022f3          csrrt0,mcause<br>800015a8:30002373          csrrt1,mstatus<br>800015ac:341023f3          csrrt2,mepc<br># 将t0,t1,t2寄存器入栈<br>800015b0:08512023          swt0,128(sp)<br>800015b4:08612223          swt1,132(sp)<br>800015b8:08712423          swt2,136(sp)<br><br>800015bc:00020537          luia0,0x20<br>800015c0:00a36333          ort1,t1,a0<br>800015c4:30031073          csrwmstatus,t1<br># 将sp寄存器复制到a0中<br># 根据RISC-V调用约定,a0被认为是向函数传递的第一个参数<br># 下文通过以上机制来向函数传参<br>800015c8:00010513          mva0,sp<br><br></code></pre></td></tr></table></figure><h1 id="4-调用AM的异常处理句柄"><a href="#4-调用AM的异常处理句柄" class="headerlink" title="4.调用AM的异常处理句柄"></a>4.调用AM的异常处理句柄</h1><h2 id="4-1-调用句柄与参数传递"><a href="#4-1-调用句柄与参数传递" class="headerlink" title="4.1 调用句柄与参数传递"></a>4.1 调用句柄与参数传递</h2><p>在<code>__am_asm_trap</code>的汇编代码中调用AM的异常处理句柄<code>cte.c</code>中的<code>__am_irq_handle</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs riscv">800015cc:e75ff0ef          jalra,80001440 &lt;__am_irq_handle&gt;<br></code></pre></td></tr></table></figure><p>之前我们提到<code>__am_asm_trap</code>通过RISC-V的调用约定向异常处理句柄<code>Context* __am_irq_handle(Context *c)</code>传递输入的参数,关于RISC-V的调用约定:</p><blockquote><ol><li>参数传递规则:<br>​整数&#x2F;指针参数：按顺序使用a0到a7，超出的部分通过栈传递（从右向左压栈）<br>​大结构体：通过指针传递，或拆分到多个寄存器&#x2F;栈空间</li><li>返回值:<br>​整数&#x2F;指针：通过a0和a1返回（64位值可能占用两个寄存器）<br>大型数据：通过内存（调用者分配空间，传递指针）</li></ol></blockquote><p>根据RISC-V的调用约定,调用者将<code>c</code>(上下文结构体的地址,也就是这里的sp)放在a0寄存器中,完成向<code>__am_irq_handle</code>参数的传递.</p><h2 id="4-2-事件分发"><a href="#4-2-事件分发" class="headerlink" title="4.2 事件分发"></a>4.2 事件分发</h2><p><code>__am_irq_handle</code>通过区别上下文结构体中mcause寄存器的值来分发事件.<br>注意在RISC-V中mepc是通过<em>软件</em>来指示+4操作的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">Event ev = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">switch</span> (c-&gt;mcause) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0xb</span> : <span class="hljs-keyword">if</span>(c-&gt;GPR1 == <span class="hljs-number">-1</span>)&#123; <br>                ev.event = EVENT_YIELD;<br>              &#125;<span class="hljs-keyword">else</span>&#123;<br>                ev.event = EVENT_SYSCALL; <br>              &#125;<br>              c-&gt;mepc += <span class="hljs-number">0x4</span>; <span class="hljs-keyword">break</span>; <br>  <span class="hljs-keyword">default</span>: ev.event = EVENT_ERROR; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-调用用户的异常回调函数"><a href="#4-3-调用用户的异常回调函数" class="headerlink" title="4.3 调用用户的异常回调函数"></a>4.3 调用用户的异常回调函数</h2><p><code>__am_irq_handle</code>的<code>c = user_handler(ev, c);</code>调用用户句柄.<code>user_handler</code>在第一步初始化CTE时定义.<br>在yield test中的回调:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">Context *<span class="hljs-title function_">simple_trap</span><span class="hljs-params">(Event ev, Context *ctx)</span> &#123;<br>  <span class="hljs-keyword">switch</span>(ev.event) &#123;<br>    <span class="hljs-keyword">case</span> EVENT_YIELD:<br>      putch(<span class="hljs-string">&#x27;y&#x27;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      panic(<span class="hljs-string">&quot;Unhandled event&quot;</span>); <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>识别EVENT_YIELD事件(在事件分发时确定),并做出响应.</p><h2 id="4-4-上下文恢复"><a href="#4-4-上下文恢复" class="headerlink" title="4.4 上下文恢复"></a>4.4 上下文恢复</h2><p>用户句柄返回一个新的上下文结构体,<code>__am_irq_handle</code>通过调用约定将这个新的结构体返回给<code>__am_asm_trap</code>.<br>程序通过<code>mret</code>指令返回到mepc的位置中(在<code>__am_irq_handle</code>中完成+4),完成异常操作.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs riscv">mv sp, a0<br>LOAD t1, OFFSET_STATUS(sp)<br>LOAD t2, OFFSET_EPC(sp)<br>csrw mstatus, t1<br>csrw mepc, t2<br><br>MAP(REGS, POP)<br><br>addi sp, sp, CONTEXT_SIZE<br>mret<br></code></pre></td></tr></table></figure><p>展开为汇编代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs riscv"># 将a0中的新的上下文结构体移动到sp,切换到新的上下文<br># 在yield test中这个还是原来的结构体保持不变<br>800015d0:00050113          mvsp,a0<br># 将上下文结构体CSR出栈,加载进硬件中<br>800015d4:08412303          lwt1,132(sp)<br>800015d8:08812383          lwt2,136(sp)<br>800015dc:30031073          csrwmstatus,t1<br>800015e0:34139073          csrwmepc,t2<br># 将上下文结构体寄存器出栈,加载进硬件中<br>800015e4:00412083          lwra,4(sp)<br>800015e8:00c12183          lwgp,12(sp)<br>800015ec:01012203          lwtp,16(sp)<br>800015f0:01412283          lwt0,20(sp)<br>800015f4:01812303          lwt1,24(sp)<br>800015f8:01c12383          lwt2,28(sp)<br>800015fc:02012403          lws0,32(sp)<br>80001600:02412483          lws1,36(sp)<br>80001604:02812503          lwa0,40(sp)<br>80001608:02c12583          lwa1,44(sp)<br>8000160c:03012603          lwa2,48(sp)<br>80001610:03412683          lwa3,52(sp)<br>80001614:03812703          lwa4,56(sp)<br>80001618:03c12783          lwa5,60(sp)<br>8000161c:04012803          lwa6,64(sp)<br>80001620:04412883          lwa7,68(sp)<br>80001624:04812903          lws2,72(sp)<br>80001628:04c12983          lws3,76(sp)<br>8000162c:05012a03          lws4,80(sp)<br>80001630:05412a83          lws5,84(sp)<br>80001634:05812b03          lws6,88(sp)<br>80001638:05c12b83          lws7,92(sp)<br>8000163c:06012c03          lws8,96(sp)<br>80001640:06412c83          lws9,100(sp)<br>80001644:06812d03          lws10,104(sp)<br>80001648:06c12d83          lws11,108(sp)<br>8000164c:07012e03          lwt3,112(sp)<br>80001650:07412e83          lwt4,116(sp)<br>80001654:07812f03          lwt5,120(sp)<br>80001658:07c12f83          lwt6,124(sp)<br># 销毁栈帧<br>8000165c:08c10113          addisp,sp,140<br># 从异常入口返回到mepc的位置<br>80001660:30200073          mret<br></code></pre></td></tr></table></figure><blockquote><p>代码最后会返回到yield test触发自陷的代码位置, 然后继续执行. 在它看来, 这次时空之旅就好像没有发生过一样.</p></blockquote><h2 id="4-5-上下文切换-PA4-1"><a href="#4-5-上下文切换-PA4-1" class="headerlink" title="4.5 上下文切换(PA4.1)"></a>4.5 上下文切换(PA4.1)</h2><p>在4.4中,yield test用户回调句柄返回的还是原来的上下文结构体,如果返回的是另一个上下文结构体呢?</p><blockquote><p>事实上, 有了CTE, 我们就有一种很巧妙的方式来实现上下文切换了. 具体地, 假设进程A运行的过程中触发了系统调用, 通过自陷指令陷入到内核. 根据<code>__am_asm_trap()</code>的代码, A的上下文结构(Context)将会被保存到A的栈上. 在PA3中, 系统调用处理完毕之后, <code>__am_asm_trap()</code>会根据栈上保存的上下文结构来恢复A的上下文. 神奇的地方来了, 如果我们先不着急恢复A的上下文, 而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢? 由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文. 从<code>__am_asm_trap()</code>返回之后, 我们已经在运行进程B了! -PA4.1</p></blockquote><p>这样的想法就被称为<em>上下文切换</em>,在<code>yield-os.c</code>中:</p><h3 id="4-5-1-进程控制块-PCB"><a href="#4-5-1-进程控制块-PCB" class="headerlink" title="4.5.1 进程控制块(PCB)"></a>4.5.1 进程控制块(PCB)</h3><p>因为每一个上下文结构体的位置都不固定,所以我们使用<code>cp</code>(Context pointer)记录上下文结构体的位置,当想要找到其它进程的上下文结构的时候, 只要寻找这个进程相关的cp指针即可.操作系统为每一个进程维护一个进程控制块(PCB),其管理进程相关的信息.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-type">uint8_t</span> <span class="hljs-built_in">stack</span>[STACK_SIZE];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> Context *cp; &#125;;<br>&#125; PCB;<br><span class="hljs-type">static</span> PCB pcb[<span class="hljs-number">2</span>], pcb_boot, *current = &amp;pcb_boot;<br></code></pre></td></tr></table></figure><p>这里cp的内存位置在栈顶. 在进行上下文切换的时候, 只需要把PCB中的cp指针返回给CTE的<code>__am_irq_handle()</code>函数即可, 剩余部分的代码会根据上下文结构恢复上下文.</p><h3 id="4-5-2-内核线程"><a href="#4-5-2-内核线程" class="headerlink" title="4.5.2 内核线程"></a>4.5.2 内核线程</h3><p>对于刚创建的进程,我们需要在栈底创建一个初始的上下文结构体,从这个上下文结构体开始正确执行此线程.同时我们需求这个内核线程可以携带一个参数,用于该线程的函数入口来调用.在恢复上下文时我们说过执行<code>mret</code>指令时程序会跳转到mepc寄存器的值,因此我们想到我们需要修改内核线程的上下文结构体的mepc为函数入口地址:<code>c-&gt;mepc = (uintptr_t)entry;</code>.同时还需要传递参数,我们通过调用约定在a0寄存器放置参数内容.</p><p>同时kcontext函数会返回此上下文结构体的指针,我们直接将其赋值给对应pcb的cp指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">pcb[<span class="hljs-number">0</span>].cp = kcontext((Area) &#123; pcb[<span class="hljs-number">0</span>].<span class="hljs-built_in">stack</span>, &amp;pcb[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &#125;, f, (<span class="hljs-type">void</span> *)<span class="hljs-number">1L</span>);<br>pcb[<span class="hljs-number">1</span>].cp = kcontext((Area) &#123; pcb[<span class="hljs-number">1</span>].<span class="hljs-built_in">stack</span>, &amp;pcb[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &#125;, f, (<span class="hljs-type">void</span> *)<span class="hljs-number">2L</span>);<br></code></pre></td></tr></table></figure><h3 id="4-5-3-用户句柄的上下文切换"><a href="#4-5-3-用户句柄的上下文切换" class="headerlink" title="4.5.3 用户句柄的上下文切换"></a>4.5.3 用户句柄的上下文切换</h3><p>在配置好不同线程的内核线程之后,我们直接进行自陷操作,一路跳转到用户异常句柄中.</p><h4 id="线程-进程调度"><a href="#线程-进程调度" class="headerlink" title="线程&#x2F;进程调度"></a>线程&#x2F;进程调度</h4><p>进行第一次自陷时:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> Context *<span class="hljs-title function_">schedule</span><span class="hljs-params">(Event ev, Context *prev)</span> &#123;<br>  current-&gt;cp = prev;<br>  current = (current == &amp;pcb[<span class="hljs-number">0</span>] ? &amp;pcb[<span class="hljs-number">1</span>] : &amp;pcb[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">return</span> current-&gt;cp; <span class="hljs-comment">// new context. then __am_irq_handle use returned context.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里通过识别<code>current</code> PCB是PCB[0]还是PCB[1],函数返回另一个上下文结构体.这里与yield test不同(另一个结构体),第一次自陷时,根据上文描述,程序跳转到PCB[0]的线程中.</p><h4 id="线程入口"><a href="#线程入口" class="headerlink" title="线程入口"></a>线程入口</h4><p>因为新的上下文结构体mepc被配置为<code>f(void *arg)</code>这个线程入口的函数地址,程序跳转到这个函数中,根据调用约定传递参数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    putch(<span class="hljs-string">&quot;?AB&quot;</span>[(<span class="hljs-type">uintptr_t</span>)arg &gt; <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : (<span class="hljs-type">uintptr_t</span>)arg]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">volatile</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) ;<br>    yield();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数通过判断当前线程携带的参数<code>arg</code>来识别是PCB[0]还是PCB[1],以此判断输出是A还是B.<br>要注意,<code>kcontext()</code>要求内核线程<strong>不能从entry返回</strong>, 否则其行为是未定义的.因此我们在线程入口调用yield进行自陷操作,继续进行上下文切换,到另一个PCB.</p><h4 id="上下文切换的示意"><a href="#上下文切换的示意" class="headerlink" title="上下文切换的示意"></a>上下文切换的示意</h4><p>第一次自陷-&gt;用户句柄 切换到PCB[0]-&gt;f() 自陷-&gt;用户句柄 切换到PCB[1]-&gt;f() 自陷-&gt;用户句柄 切换到PCB[0]-&gt;f() 自陷-&gt; …</p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2.3必答-编译与链接-关于static与inline关键字</title>
    <link href="/2025/02/27/PA2-3%E5%BF%85%E7%AD%94-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5-%E5%85%B3%E4%BA%8Estatic%E4%B8%8Einline%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2025/02/27/PA2-3%E5%BF%85%E7%AD%94-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5-%E5%85%B3%E4%BA%8Estatic%E4%B8%8Einline%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>记录笔者在完成PA2.3必答题”去掉static,inline”时遇到的问题解答与思考.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><blockquote><p><strong>PA2 必答题:编译与链接</strong><br>编译与链接 在nemu&#x2F;include&#x2F;cpu&#x2F;ifetch.h中, 你会看到由static inline开头定义的inst_fetch()函数. 分别尝试去掉static, 去掉inline或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生&#x2F;不发生? 你有办法证明你的想法吗?</p></blockquote><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>直接放结果:</p><ul><li>仅删去static,无事发生</li><li>仅删去inline,无事发生</li><li>删去static和inline,链接报错误<code>multiple definition</code></li></ul><p><strong>这是为什么呢?</strong></p><h1 id="static和inline的作用"><a href="#static和inline的作用" class="headerlink" title="static和inline的作用"></a>static和inline的作用</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ol><li><strong>对符号可见性的限制</strong><br>当用static修饰全局函数或全局变量时，其作用域被限制在当前编译单元（即当前源文件）。其他文件无法通过extern声明访问它。</li><li><strong>对ELF符号表的影响</strong><br>在编译生成的ELF目标文件（.o）的符号表中：</li></ol><ul><li>static修饰的符号会被标记为LOCAL绑定类型。</li><li>未用static修饰的全局符号会被标记为GLOBAL绑定类型。<br>在链接时链接器仅处理GLOBAL符号,忽略LOCAL符号(视为各自文件的私有符号).<br>具体来说,在链接时使用static修饰的符号为局部符号,在其他源文件中不可见,不检查多重定义,故多个源文件可定义同名的static变量.</li></ul><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>GCC手册说:</p><blockquote><p>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function’s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function’s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case.<br>通过内联声明函数，您可以指示 GCC 更快地调用该函数。GCC 实现此目的的一种方法是将该函数的代码集成到其调用者的代码中。这通过消除函数调用开销来加快执行速度;此外，如果任何实际参数值是常量，则它们的已知值可能允许在编译时进行简化，以便不需要包含内联函数的所有代码。对代码大小的影响更难预测;使用函数内联时，目标代码可能会更大或更小，具体取决于特定情况。</p></blockquote><p>即通过inline关键字,GCC可以将函数内联进调用者的代码中.然而GCC手册又说:</p><blockquote><p>When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.<br>当内联函数不是静态的时，编译器必须假定可能存在来自其他源文件的调用;由于一个全局符号在任何程序中只能定义一次，因此该函数不能在其他源文件中定义，因此其中的调用不能集成。因此，非静态内联函数总是以通常的方式自行编译。</p></blockquote><p>当仅使用inline时,必须在某个源文件中使用extern inline显式提供该函数的外部定义,否则链接器无法找到符号.</p><blockquote><p>If you specify both inline and extern in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.<br>如果在函数定义中同时指定 inline 和 extern，则该定义仅用于内联。在任何情况下，函数都不会自行编译，即使您显式引用其地址也是如此。这样的地址成为外部引用，就好像您只声明了该函数而没有定义它一样。</p></blockquote><p>我们有如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// utils.h</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// file1.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123; f() &#125;<br></code></pre></td></tr></table></figure><p>我们使用<code>gcc file1.o -o out</code>进行链接,出现错误<code> undefined reference to &#39;f&#39;</code>,通过上文我们可以知道,我们在链接时使用了inline函数但却没有使用extern inline显式提供函数体,我们使用readelf看到f是UND,链接器报错.</p><p>将<code>utils.h</code>中的inline改为static inline时,链接不报错.这是因为在此时我们使用了static inline,我们使用readelf看到f是LOCAL,其被认为是一个局部符号.</p><h1 id="透过现象看本质"><a href="#透过现象看本质" class="headerlink" title="透过现象看本质"></a>透过现象看本质</h1><ul><li>当我们只保留static时,此时inst_fetch函数是静态函数,不内联,链接不会报错.</li><li>当我们只保留inline时,此时可能所有调用被内联,链接有可能不报错.<br>为了证明这点,我们在CFLAGS中加入<code>-fno-inline</code>强制禁止内联,出现错误<code>undefined reference to &#39;inst_fetch&#39;</code>,这是因为inline默认为局部符号,而在源文件不存在其定义.<br>我们也可以通过elf的符号表证明这点.在没有<code>-fno-inline</code> 时<code>hostcall.o</code>和<code>inst.o</code>的符号表均不存在<code>inst_fetch</code>,即其被内联,而在有<code>-fno-inline</code>时两个文件<code>inst_fetch</code>符号均为UND.</li><li>当static和inline都没有时,此时全局符号在头文件被定义,必然引起重复定义错误.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU中IFDEF宏的实现方法</title>
    <link href="/2025/02/26/NEMU%E4%B8%ADIFDEF%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2025/02/26/NEMU%E4%B8%ADIFDEF%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>NEMU中marco.h的宏实现十分神奇,这里以IFDEF宏的实现为例子,简单介绍一下.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><p><strong>目的：实现#IFDEF(CONFIG_ITRACE, init_disasm())宏，若CONFIG_ITRACE宏被定义，则执行函数init_disasm()，否则不执行任何函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><span class="hljs-comment">// define placeholders for some property</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_DEF_1  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_ONE_1  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_ZERO_0 X,</span><br><span class="hljs-comment">// define some selection functions based on the properties of BOOLEAN macro</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXDEF(macro, X, Y)  MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXNDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, Y, X)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXONE(macro, X, Y)  MUX_MACRO_PROPERTY(__P_ONE_, macro, X, Y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXZERO(macro, X, Y) MUX_MACRO_PROPERTY(__P_ZERO_,macro, X, Y)</span><br><br><span class="hljs-comment">// simplification for conditional compilation</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p><code>#define ISDEF(macro) MUXDEF(macro, 1, 0)</code><br><code>#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</code><br><code>#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</code><br>若MARCO_1被定义：<br><code>MUXDEF(MACRO_1, 1, 0)</code><br>被展开为<br><code>MUX_MACRO_PROPERTY(__P_DEF_, MACRO_1, 1, 0)</code><br>拼接连接符<br><code>concat(__P_DEF_, MACRO_1)  // 结果为 __P_DEF_0</code><br><code>#define __P_DEF_0 X,  // 包含逗号 </code><br>被展开为<code>MUX_WITH_COMMA(__P_DEF_0, 1, 0)</code><br>被展开为<code>CHOOSE2nd(X, , 1, 0)  // 选择第二个参数：space</code><br>(逗号替换逻辑，这里‘X,’作为一个整体传进去，即X,就是一个参数，space之后的逗号是分割这个整体的，而’X,’内的逗号又会导致其被解析成两个参数。)</p><p>对于<br><code>#define CONFIG_ITRACE  // 假设 CONFIG_ITRACE 被定义</code><br><code>IFDEF(CONFIG_ITRACE, init_disasm());</code><br>调用#IFDEF<br><code>MUXDEF(CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>展开MUXDEF<br><code>MUX_MACRO_PROPERTY(__P_DEF_, CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>拼接连接符<br><code>concat(__P_DEF_, CONFIG_ITRACE) -&gt; __P_DEF_1</code><br><code>#define __P_DEF_1 X,</code><br>其结果<br><code>MUX_WITH_COMMA(__P_DEF_1, __KEEP, __IGNORE)(init_disasm());</code><br>处理MUX_WITH_COMMA<br><code>CHOOSE2nd(__P_DEF_1 __KEEP, __IGNORE)(init_disasm());</code><br>__P_DEF_1 包含一个逗号,被展开为’ X,__KEEP, __IGNORE’，所以选择第二个参数 __KEEP：<br><code>__KEEP(init_disasm());</code><br>调用__KEEP<br><code>init_disasm();</code><br>实现若CONFIG_ITRACE被定义，执行init_disasm();的效果。</p><p>而若CONFIG_ITRACE宏未定义：<br><code>IFDEF(CONFIG_ITRACE, init_disasm());</code><br>调用#IFDEF<br><code>MUXDEF(CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>拼接连接符，现在其未被定义<br><code>concat(__P_DEF_, CONFIG_ITRACE) -&gt; __P_DEF_ CONFIG_ITRACE</code><br>其结果<br><code>MUX_WITH_COMMA(__P_DEF_ CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>处理MUX_WITH_COMMA<br><code>CHOOSE2nd(__P_DEF_ CONFIG_ITRACE __KEEP, __IGNORE)(init_disasm());</code><br>现在__P_DEF_ CONFIG_ITRACE __KEEP,未被定义（不像上个例子能被展开为‘X,’）<br>此时选择第二个参数__IGNORE<br><code>__IGNORE(init_disasm())</code><br>展开为空。<br>实现若CONFIG_ITRACE未被定义，不执行任何函数的效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2-1-RTFSC理解NEMU指令执行过程</title>
    <link href="/2025/02/26/PA2-1-RTFSC%E7%90%86%E8%A7%A3NEMU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/02/26/PA2-1-RTFSC%E7%90%86%E8%A7%A3NEMU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>对NEMU如何执行一条指令的理解.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,本人并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><h2 id="0-主要的数据结构"><a href="#0-主要的数据结构" class="headerlink" title="0 主要的数据结构"></a>0 主要的数据结构</h2><p>注意：snpc和dnpc：  </p><ul><li>snpc: static next pc，二进制代码中的下一个pc  </li><li>dnpc：dynamic next pc，下一个程序执行的pc<br>例如，<br>100: jmp 102<br>101: add<br>102: xor<br>100 的 snpc 为 101，100 的 dnpc 为 102。<br>因此，我们在执行指令时应该使用dnpc来更新pc并维护dnpc。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Decode</span> &#123;</span><br>    <span class="hljs-type">vaddr_t</span> pc;<br>    <span class="hljs-type">vaddr_t</span> snpc; <span class="hljs-comment">// static next pc</span><br>    <span class="hljs-type">vaddr_t</span> dnpc; <span class="hljs-comment">// dynamic next pc</span><br>    ISADecodeInfo isa; <br>    IFDEF(CONFIG_ITRACE, <span class="hljs-type">char</span> logbuf[<span class="hljs-number">128</span>]);<br>&#125; Decode;<br></code></pre></td></tr></table></figure><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>更新pc与snpc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">s-&gt;pc = pc;<br>s-&gt;snpc = pc;<span class="hljs-comment">// update s-&gt;pc and s-&gt;snpc.</span><br>isa_exec_once(s); <span class="hljs-comment">// fetch and execute code s-&gt;pc and update s-&gt; dnpc.</span><br></code></pre></td></tr></table></figure><h2 id="2-取指"><a href="#2-取指" class="headerlink" title="2 取指"></a>2 取指</h2><p>NEMU在内存中读指令（4字节）并更新snpc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">s-&gt;isa.inst = inst_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>); <span class="hljs-comment">// fetch inst in mem (4 bytes) and update s-&gt;snpc.</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">inst_fetch</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> *pc, <span class="hljs-type">int</span> len)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> inst = vaddr_ifetch(*pc, len);<br>  (*pc) += len;<br>  <span class="hljs-keyword">return</span> inst;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-译码"><a href="#3-译码" class="headerlink" title="3 译码"></a>3 译码</h2><p>NEMU通过模式匹配，匹配到指令结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Here to decode */</span><br>INSTPAT_START();<br>INSTPAT(<span class="hljs-string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, auipc  , U, R(rd) = s-&gt;pc + imm);<br>INSTPAT_END();<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSTPAT(pattern, ...) do &#123; \</span><br><span class="hljs-meta">  uint64_t key, mask, shift; \</span><br><span class="hljs-meta">  <span class="hljs-comment">/* Decode the pattern and get key code, mask and shift of the pattern. */</span></span><br>  pattern_decode(pattern, STRLEN(pattern), &amp;key, &amp;mask, &amp;shift); \<br>  <span class="hljs-comment">/* Get inst and if inst matches the pattern */</span><br>  <span class="hljs-keyword">if</span> ((((<span class="hljs-type">uint64_t</span>)INSTPAT_INST(s) &gt;&gt; shift) &amp; mask) == key) &#123; \<br>    INSTPAT_MATCH(s, ##__VA_ARGS__); \<br>    <span class="hljs-keyword">goto</span> *(__instpat_end); \<br>  &#125; \<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="3-1-匹配模式过程"><a href="#3-1-匹配模式过程" class="headerlink" title="3.1 匹配模式过程"></a>3.1 匹配模式过程</h3><p><code>pattern_decode(pattern, STRLEN(pattern), &amp;key, &amp;mask, &amp;shift);</code>用于对模式解码并得到键码，掩码与偏移。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C">/ --- pattern matching mechanism ---<br>__attribute__((always_inline))<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pattern_decode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">int</span> len,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> *key, <span class="hljs-type">uint64_t</span> *mask, <span class="hljs-type">uint64_t</span> *shift)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> __key = <span class="hljs-number">0</span>, __mask = <span class="hljs-number">0</span>, __shift = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro(i) \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> ((i) &gt;= len) goto finish; \</span><br><span class="hljs-meta">  <span class="hljs-keyword">else</span> &#123; \</span><br><span class="hljs-meta">    char c = str[i]; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) &#123; \</span><br><span class="hljs-meta">      Assert(c == <span class="hljs-string">&#x27;0&#x27;</span> || c == <span class="hljs-string">&#x27;1&#x27;</span> || c == <span class="hljs-string">&#x27;?&#x27;</span>, \</span><br><span class="hljs-meta">          <span class="hljs-string">&quot;invalid character &#x27;%c&#x27; in pattern string&quot;</span>, c); \</span><br><span class="hljs-meta">      <span class="hljs-comment">/* 得到指令的键码__key与掩码__mask。 </span></span><br><span class="hljs-comment"><span class="hljs-meta">       * __shift为LSB至opcode的距离位数。</span></span><br><span class="hljs-comment"><span class="hljs-meta">       */</span></span><br>      __key  = (__key  &lt;&lt; <span class="hljs-number">1</span>) | (c == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); \<br>      __mask = (__mask &lt;&lt; <span class="hljs-number">1</span>) | (c == <span class="hljs-string">&#x27;?&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>); \<br>      __shift = (c == <span class="hljs-string">&#x27;?&#x27;</span> ? __shift + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); \<br>    &#125; \<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro2(i)  macro(i);   macro((i) + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro4(i)  macro2(i);  macro2((i) + 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro8(i)  macro4(i);  macro4((i) + 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro16(i) macro8(i);  macro8((i) + 8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro32(i) macro16(i); macro16((i) + 16)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro64(i) macro32(i); macro32((i) + 32)</span><br>  <span class="hljs-comment">/* 这里使用了递归的宏展开来对每一位都进行解码 */</span><br>  macro64(<span class="hljs-number">0</span>);<br>  panic(<span class="hljs-string">&quot;pattern too long&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> macro</span><br>finish:<br><span class="hljs-comment">/*注意：这里，我们需要将键码、掩码和移位移动到正确的位置。</span><br><span class="hljs-comment">   * 移位是从 LSB 到操作码的位数，用于匹配操作码。</span><br><span class="hljs-comment">   * 密钥和掩码通过移位位向右移动。</span><br><span class="hljs-comment">   * 例如，“?????? ?????? ?????? ??? ?????? 00101 11”将被解码为</span><br><span class="hljs-comment">   * key = 0x17，mask = 0x7f，移位 = 0。</span><br><span class="hljs-comment">   */</span><br>  *key = __key &gt;&gt; __shift;<br>  *mask = __mask &gt;&gt; __shift;<br>  *shift = __shift;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到了特定指令的匹配规律，我们就可以对取到的指令进行逐一匹配了。<br></p><h3 id="3-2-指令匹配过程"><a href="#3-2-指令匹配过程" class="headerlink" title="3.2 指令匹配过程"></a>3.2 指令匹配过程</h3><p><code>if ((((uint64_t)INSTPAT_INST(s) &gt;&gt; shift) &amp; mask) == key) &#123; \</code>这条if语句对取到的指令进行匹配,<br><br>如符合，则执行<code>INSTPAT_MATCH(s, ##__VA_ARGS__); \</code>。<br><br>这个宏在decode_exec中定义。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSTPAT_MATCH(s, name, type, ... <span class="hljs-comment">/* execute body */</span> ) &#123; \</span><br><span class="hljs-meta">  int rd = 0; \</span><br><span class="hljs-meta">  word_t src1 = 0, src2 = 0, imm = 0; \</span><br><span class="hljs-meta">  decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, concat(TYPE_, type)); \</span><br><span class="hljs-meta">  __VA_ARGS__ ; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-立即数译码过程"><a href="#3-3-立即数译码过程" class="headerlink" title="3.3 立即数译码过程"></a>3.3 立即数译码过程</h3><p>这里的decode_operand用来对立即数进行译码。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  TYPE_I, TYPE_U, TYPE_S,<br>  TYPE_N, <span class="hljs-comment">// none</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> src1R() do &#123; *src1 = R(rs1); &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> src2R() do &#123; *src2 = R(rs2); &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immI() do &#123; *imm = SEXT(BITS(i, 31, 20), 12); &#125; while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immU() do &#123; *imm = SEXT(BITS(i, 31, 12), 20) &lt;&lt; 12; &#125; while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immS() do &#123; *imm = (SEXT(BITS(i, 31, 25), 7) &lt;&lt; 5) | BITS(i, 11, 7); &#125; while(0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">decode_operand</span><span class="hljs-params">(Decode *s, <span class="hljs-type">int</span> *rd, <span class="hljs-type">word_t</span> *src1, <span class="hljs-type">word_t</span> *src2, <span class="hljs-type">word_t</span> *imm, <span class="hljs-type">int</span> type)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> i = s-&gt;isa.inst;<br>  <span class="hljs-type">int</span> rs1 = BITS(i, <span class="hljs-number">19</span>, <span class="hljs-number">15</span>);<br>  <span class="hljs-type">int</span> rs2 = BITS(i, <span class="hljs-number">24</span>, <span class="hljs-number">20</span>);<br>  *rd     = BITS(i, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>);<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> TYPE_I: src1R();          immI(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_U:                   immU(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_S: src1R(); src2R(); immS(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_N: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: panic(<span class="hljs-string">&quot;unsupported type = %d&quot;</span>, type);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中存在五个辅助宏，用于便捷的获取立即数。<br></p><h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4 执行"></a>4 执行</h2><p>程序执行<code>INSTPAT(&quot;??????? ????? ????? ??? ????? 00101 11&quot;, auipc  , U, R(rd) = s-&gt;pc + imm);</code><br><br>中的<code>R(rd) = s-&gt;pc + imm</code>指令。指令执行的阶段结束之后, decode_exec()函数将会返回0, 并一路返回到exec_once()函数中。<br></p><h2 id="5-更新PC"><a href="#5-更新PC" class="headerlink" title="5 更新PC"></a>5 更新PC</h2><p>上文已经提到snpc与dnpc的区别，在程序执行时我们需要正确维护dnpc。<br><br><code>cpu.pc = s-&gt;dnpc;</code>来更新dnpc。<br></p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2.3-程序如何在AM上运行</title>
    <link href="/2025/02/26/PA2-3-%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%9C%A8AM%E4%B8%8A%E8%BF%90%E8%A1%8C/"/>
    <url>/2025/02/26/PA2-3-%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%9C%A8AM%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>对整个计算机系统(NEMU,ISA,AM,运行时环境,程序)相互联系的个人理解.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><h2 id="计算机是个抽象层-程序如何在计算机上运行"><a href="#计算机是个抽象层-程序如何在计算机上运行" class="headerlink" title="计算机是个抽象层:程序如何在计算机上运行"></a>计算机是个抽象层:程序如何在计算机上运行</h2><ul><li>AM为程序提供了运行时环境.</li><li>AM将NEMU的接口做了一层抽象,NEMU是底层的硬件模拟层(处理指令执行、设备交互),而AM在此之上构建软件抽象层.</li><li>AM和NEMU的运行依赖于宿主环境的运行时环境.</li></ul><h3 id="NEMU与AM如何协同工作"><a href="#NEMU与AM如何协同工作" class="headerlink" title="NEMU与AM如何协同工作"></a>NEMU与AM如何协同工作</h3><p>NEMU中进行注册内存映射操作,将一块内存映射到NEMU的端口中(MMIO),并设定回调函数,当有对这块内存读写操作时就调用回调函数.在回调函数中使用C语言的API更新对应设备.<br>AM中对内存进行读写,间接的操控设备.</p><h3 id="AM-运行时环境-程序如何协同工作"><a href="#AM-运行时环境-程序如何协同工作" class="headerlink" title="AM,运行时环境,程序如何协同工作"></a>AM,运行时环境,程序如何协同工作</h3><p>AM为程序提供了运行时环境,程序通过调用AM提供的IOE接口访问AM中的抽象寄存器并触发回调函数,而AM通过读取抽象寄存器的值对MMIO进行读写.以这种方法程序间接实现对MMIO的读写,控制设备.</p><h2 id="程序是个状态机-游戏是如何运行的"><a href="#程序是个状态机-游戏是如何运行的" class="headerlink" title="程序是个状态机:游戏是如何运行的"></a>程序是个状态机:游戏是如何运行的</h2><ul><li>初始化:ioe_init初始化IOE,video_init初始化VGA,读取timer的初始值</li><li>获取游戏运行时间(时钟)</li><li>更新游戏逻辑(TRM)</li><li>读取键盘按键(键盘):NONE-&gt;下一个状态,Esc-&gt;halt,按键-&gt;检查是否命中-&gt;下一个状态</li><li>刷新页面(VGA)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
