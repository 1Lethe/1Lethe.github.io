<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PA2.3必答-编译与链接-关于static与inline关键字</title>
    <link href="/2025/02/27/PA2-3%E5%BF%85%E7%AD%94-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5-%E5%85%B3%E4%BA%8Estatic%E4%B8%8Einline%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2025/02/27/PA2-3%E5%BF%85%E7%AD%94-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5-%E5%85%B3%E4%BA%8Estatic%E4%B8%8Einline%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>记录笔者在完成PA2.3必答题”去掉static,inline”时遇到的问题解答与思考.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><blockquote><p><strong>PA2 必答题:编译与链接</strong><br>编译与链接 在nemu&#x2F;include&#x2F;cpu&#x2F;ifetch.h中, 你会看到由static inline开头定义的inst_fetch()函数. 分别尝试去掉static, 去掉inline或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生&#x2F;不发生? 你有办法证明你的想法吗?</p></blockquote><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>直接放结果:</p><ul><li>仅删去static,无事发生</li><li>仅删去inline,无事发生</li><li>删去static和inline,链接报错误<code>multiple definition</code></li></ul><p><strong>这是为什么呢?</strong></p><h1 id="static和inline的作用"><a href="#static和inline的作用" class="headerlink" title="static和inline的作用"></a>static和inline的作用</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ol><li><strong>对符号可见性的限制</strong><br>当用static修饰全局函数或全局变量时，其作用域被限制在当前编译单元（即当前源文件）。其他文件无法通过extern声明访问它。</li><li><strong>对ELF符号表的影响</strong><br>在编译生成的ELF目标文件（.o）的符号表中：</li></ol><ul><li>static修饰的符号会被标记为LOCAL绑定类型。</li><li>未用static修饰的全局符号会被标记为GLOBAL绑定类型。<br>在链接时链接器仅处理GLOBAL符号,忽略LOCAL符号(视为各自文件的私有符号).<br>具体来说,在链接时使用static修饰的符号为局部符号,在其他源文件中不可见,不检查多重定义,故多个源文件可定义同名的static变量.</li></ul><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>GCC手册说:</p><blockquote><p>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function’s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function’s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case.<br>通过内联声明函数，您可以指示 GCC 更快地调用该函数。GCC 实现此目的的一种方法是将该函数的代码集成到其调用者的代码中。这通过消除函数调用开销来加快执行速度;此外，如果任何实际参数值是常量，则它们的已知值可能允许在编译时进行简化，以便不需要包含内联函数的所有代码。对代码大小的影响更难预测;使用函数内联时，目标代码可能会更大或更小，具体取决于特定情况。</p></blockquote><p>即通过inline关键字,GCC可以将函数内联进调用者的代码中.然而GCC手册又说:</p><blockquote><p>When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.<br>当内联函数不是静态的时，编译器必须假定可能存在来自其他源文件的调用;由于一个全局符号在任何程序中只能定义一次，因此该函数不能在其他源文件中定义，因此其中的调用不能集成。因此，非静态内联函数总是以通常的方式自行编译。</p></blockquote><p>当仅使用inline时,必须在某个源文件中使用extern inline显式提供该函数的外部定义,否则链接器无法找到符号.</p><blockquote><p>If you specify both inline and extern in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.<br>如果在函数定义中同时指定 inline 和 extern，则该定义仅用于内联。在任何情况下，函数都不会自行编译，即使您显式引用其地址也是如此。这样的地址成为外部引用，就好像您只声明了该函数而没有定义它一样。</p></blockquote><p>我们有如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// utils.h</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// file1.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123; f() &#125;<br></code></pre></td></tr></table></figure><p>我们使用<code>gcc file1.o -o out</code>进行链接,出现错误<code> undefined reference to &#39;f&#39;</code>,通过上文我们可以知道,我们在链接时使用了inline函数但却没有使用extern inline显式提供函数体,我们使用readelf看到f是UND,链接器报错.</p><p>将<code>utils.h</code>中的inline改为static inline时,链接不报错.这是因为在此时我们使用了static inline,我们使用readelf看到f是LOCAL,其被认为是一个局部符号.</p><h1 id="透过现象看本质"><a href="#透过现象看本质" class="headerlink" title="透过现象看本质"></a>透过现象看本质</h1><ul><li>当我们只保留static时,此时inst_fetch函数是静态函数,不内联,链接不会报错.</li><li>当我们只保留inline时,此时可能所有调用被内联,链接有可能不报错.<br>为了证明这点,我们在CFLAGS中加入<code>-fno-inline</code>强制禁止内联,出现错误<code>undefined reference to &#39;inst_fetch&#39;</code>,这是因为inline默认为局部符号,而在源文件不存在其定义.<br>我们也可以通过elf的符号表证明这点.在没有<code>-fno-inline</code> 时<code>hostcall.o</code>和<code>inst.o</code>的符号表均不存在<code>inst_fetch</code>,即其被内联,而在有<code>-fno-inline</code>时两个文件<code>inst_fetch</code>符号均为UND.</li><li>当static和inline都没有时,此时全局符号在头文件被定义,必然引起重复定义错误.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NEMU中IFDEF宏的实现方法</title>
    <link href="/2025/02/26/NEMU%E4%B8%ADIFDEF%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2025/02/26/NEMU%E4%B8%ADIFDEF%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>NEMU中marco.h的宏实现十分神奇,这里以IFDEF宏的实现为例子,简单介绍一下.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><p><strong>目的：实现#IFDEF(CONFIG_ITRACE, init_disasm())宏，若CONFIG_ITRACE宏被定义，则执行函数init_disasm()，否则不执行任何函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHOOSE2nd(a, b, ...) b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</span><br><span class="hljs-comment">// define placeholders for some property</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_DEF_0  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_DEF_1  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_ONE_1  X,</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __P_ZERO_0 X,</span><br><span class="hljs-comment">// define some selection functions based on the properties of BOOLEAN macro</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXDEF(macro, X, Y)  MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXNDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, Y, X)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXONE(macro, X, Y)  MUX_MACRO_PROPERTY(__P_ONE_, macro, X, Y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUXZERO(macro, X, Y) MUX_MACRO_PROPERTY(__P_ZERO_,macro, X, Y)</span><br><br><span class="hljs-comment">// simplification for conditional compilation</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __IGNORE(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KEEP(...) __VA_ARGS__</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is undefined</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br><span class="hljs-comment">// keep the code if a boolean macro is defined to 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)</span><br></code></pre></td></tr></table></figure><p><code>#define ISDEF(macro) MUXDEF(macro, 1, 0)</code><br><code>#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)</code><br><code>#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)</code><br>若MARCO_1被定义：<br><code>MUXDEF(MACRO_1, 1, 0)</code><br>被展开为<br><code>MUX_MACRO_PROPERTY(__P_DEF_, MACRO_1, 1, 0)</code><br>拼接连接符<br><code>concat(__P_DEF_, MACRO_1)  // 结果为 __P_DEF_0</code><br><code>#define __P_DEF_0 X,  // 包含逗号 </code><br>被展开为<code>MUX_WITH_COMMA(__P_DEF_0, 1, 0)</code><br>被展开为<code>CHOOSE2nd(X, , 1, 0)  // 选择第二个参数：space</code><br>(逗号替换逻辑，这里‘X,’作为一个整体传进去，即X,就是一个参数，space之后的逗号是分割这个整体的，而’X,’内的逗号又会导致其被解析成两个参数。)</p><p>对于<br><code>#define CONFIG_ITRACE  // 假设 CONFIG_ITRACE 被定义</code><br><code>IFDEF(CONFIG_ITRACE, init_disasm());</code><br>调用#IFDEF<br><code>MUXDEF(CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>展开MUXDEF<br><code>MUX_MACRO_PROPERTY(__P_DEF_, CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>拼接连接符<br><code>concat(__P_DEF_, CONFIG_ITRACE) -&gt; __P_DEF_1</code><br><code>#define __P_DEF_1 X,</code><br>其结果<br><code>MUX_WITH_COMMA(__P_DEF_1, __KEEP, __IGNORE)(init_disasm());</code><br>处理MUX_WITH_COMMA<br><code>CHOOSE2nd(__P_DEF_1 __KEEP, __IGNORE)(init_disasm());</code><br>__P_DEF_1 包含一个逗号,被展开为’ X,__KEEP, __IGNORE’，所以选择第二个参数 __KEEP：<br><code>__KEEP(init_disasm());</code><br>调用__KEEP<br><code>init_disasm();</code><br>实现若CONFIG_ITRACE被定义，执行init_disasm();的效果。</p><p>而若CONFIG_ITRACE宏未定义：<br><code>IFDEF(CONFIG_ITRACE, init_disasm());</code><br>调用#IFDEF<br><code>MUXDEF(CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>拼接连接符，现在其未被定义<br><code>concat(__P_DEF_, CONFIG_ITRACE) -&gt; __P_DEF_ CONFIG_ITRACE</code><br>其结果<br><code>MUX_WITH_COMMA(__P_DEF_ CONFIG_ITRACE, __KEEP, __IGNORE)(init_disasm());</code><br>处理MUX_WITH_COMMA<br><code>CHOOSE2nd(__P_DEF_ CONFIG_ITRACE __KEEP, __IGNORE)(init_disasm());</code><br>现在__P_DEF_ CONFIG_ITRACE __KEEP,未被定义（不像上个例子能被展开为‘X,’）<br>此时选择第二个参数__IGNORE<br><code>__IGNORE(init_disasm())</code><br>展开为空。<br>实现若CONFIG_ITRACE未被定义，不执行任何函数的效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2-1-RTFSC理解NEMU指令执行过程</title>
    <link href="/2025/02/26/PA2-1-RTFSC%E7%90%86%E8%A7%A3NEMU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/02/26/PA2-1-RTFSC%E7%90%86%E8%A7%A3NEMU%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>对NEMU如何执行一条指令的理解.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,本人并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><h2 id="0-主要的数据结构"><a href="#0-主要的数据结构" class="headerlink" title="0 主要的数据结构"></a>0 主要的数据结构</h2><p>注意：snpc和dnpc：  </p><ul><li>snpc: static next pc，二进制代码中的下一个pc  </li><li>dnpc：dynamic next pc，下一个程序执行的pc<br>例如，<br>100: jmp 102<br>101: add<br>102: xor<br>100 的 snpc 为 101，100 的 dnpc 为 102。<br>因此，我们在执行指令时应该使用dnpc来更新pc并维护dnpc。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Decode</span> &#123;</span><br>    <span class="hljs-type">vaddr_t</span> pc;<br>    <span class="hljs-type">vaddr_t</span> snpc; <span class="hljs-comment">// static next pc</span><br>    <span class="hljs-type">vaddr_t</span> dnpc; <span class="hljs-comment">// dynamic next pc</span><br>    ISADecodeInfo isa; <br>    IFDEF(CONFIG_ITRACE, <span class="hljs-type">char</span> logbuf[<span class="hljs-number">128</span>]);<br>&#125; Decode;<br></code></pre></td></tr></table></figure><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>更新pc与snpc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">s-&gt;pc = pc;<br>s-&gt;snpc = pc;<span class="hljs-comment">// update s-&gt;pc and s-&gt;snpc.</span><br>isa_exec_once(s); <span class="hljs-comment">// fetch and execute code s-&gt;pc and update s-&gt; dnpc.</span><br></code></pre></td></tr></table></figure><h2 id="2-取指"><a href="#2-取指" class="headerlink" title="2 取指"></a>2 取指</h2><p>NEMU在内存中读指令（4字节）并更新snpc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">s-&gt;isa.inst = inst_fetch(&amp;s-&gt;snpc, <span class="hljs-number">4</span>); <span class="hljs-comment">// fetch inst in mem (4 bytes) and update s-&gt;snpc.</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">inst_fetch</span><span class="hljs-params">(<span class="hljs-type">vaddr_t</span> *pc, <span class="hljs-type">int</span> len)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> inst = vaddr_ifetch(*pc, len);<br>  (*pc) += len;<br>  <span class="hljs-keyword">return</span> inst;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-译码"><a href="#3-译码" class="headerlink" title="3 译码"></a>3 译码</h2><p>NEMU通过模式匹配，匹配到指令结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Here to decode */</span><br>INSTPAT_START();<br>INSTPAT(<span class="hljs-string">&quot;??????? ????? ????? ??? ????? 00101 11&quot;</span>, auipc  , U, R(rd) = s-&gt;pc + imm);<br>INSTPAT_END();<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSTPAT(pattern, ...) do &#123; \</span><br><span class="hljs-meta">  uint64_t key, mask, shift; \</span><br><span class="hljs-meta">  <span class="hljs-comment">/* Decode the pattern and get key code, mask and shift of the pattern. */</span></span><br>  pattern_decode(pattern, STRLEN(pattern), &amp;key, &amp;mask, &amp;shift); \<br>  <span class="hljs-comment">/* Get inst and if inst matches the pattern */</span><br>  <span class="hljs-keyword">if</span> ((((<span class="hljs-type">uint64_t</span>)INSTPAT_INST(s) &gt;&gt; shift) &amp; mask) == key) &#123; \<br>    INSTPAT_MATCH(s, ##__VA_ARGS__); \<br>    <span class="hljs-keyword">goto</span> *(__instpat_end); \<br>  &#125; \<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="3-1-匹配模式过程"><a href="#3-1-匹配模式过程" class="headerlink" title="3.1 匹配模式过程"></a>3.1 匹配模式过程</h3><p><code>pattern_decode(pattern, STRLEN(pattern), &amp;key, &amp;mask, &amp;shift);</code>用于对模式解码并得到键码，掩码与偏移。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C">/ --- pattern matching mechanism ---<br>__attribute__((always_inline))<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pattern_decode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">int</span> len,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> *key, <span class="hljs-type">uint64_t</span> *mask, <span class="hljs-type">uint64_t</span> *shift)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> __key = <span class="hljs-number">0</span>, __mask = <span class="hljs-number">0</span>, __shift = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro(i) \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> ((i) &gt;= len) goto finish; \</span><br><span class="hljs-meta">  <span class="hljs-keyword">else</span> &#123; \</span><br><span class="hljs-meta">    char c = str[i]; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) &#123; \</span><br><span class="hljs-meta">      Assert(c == <span class="hljs-string">&#x27;0&#x27;</span> || c == <span class="hljs-string">&#x27;1&#x27;</span> || c == <span class="hljs-string">&#x27;?&#x27;</span>, \</span><br><span class="hljs-meta">          <span class="hljs-string">&quot;invalid character &#x27;%c&#x27; in pattern string&quot;</span>, c); \</span><br><span class="hljs-meta">      <span class="hljs-comment">/* 得到指令的键码__key与掩码__mask。 </span></span><br><span class="hljs-comment"><span class="hljs-meta">       * __shift为LSB至opcode的距离位数。</span></span><br><span class="hljs-comment"><span class="hljs-meta">       */</span></span><br>      __key  = (__key  &lt;&lt; <span class="hljs-number">1</span>) | (c == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); \<br>      __mask = (__mask &lt;&lt; <span class="hljs-number">1</span>) | (c == <span class="hljs-string">&#x27;?&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>); \<br>      __shift = (c == <span class="hljs-string">&#x27;?&#x27;</span> ? __shift + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); \<br>    &#125; \<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro2(i)  macro(i);   macro((i) + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro4(i)  macro2(i);  macro2((i) + 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro8(i)  macro4(i);  macro4((i) + 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro16(i) macro8(i);  macro8((i) + 8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro32(i) macro16(i); macro16((i) + 16)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> macro64(i) macro32(i); macro32((i) + 32)</span><br>  <span class="hljs-comment">/* 这里使用了递归的宏展开来对每一位都进行解码 */</span><br>  macro64(<span class="hljs-number">0</span>);<br>  panic(<span class="hljs-string">&quot;pattern too long&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> macro</span><br>finish:<br><span class="hljs-comment">/*注意：这里，我们需要将键码、掩码和移位移动到正确的位置。</span><br><span class="hljs-comment">   * 移位是从 LSB 到操作码的位数，用于匹配操作码。</span><br><span class="hljs-comment">   * 密钥和掩码通过移位位向右移动。</span><br><span class="hljs-comment">   * 例如，“?????? ?????? ?????? ??? ?????? 00101 11”将被解码为</span><br><span class="hljs-comment">   * key = 0x17，mask = 0x7f，移位 = 0。</span><br><span class="hljs-comment">   */</span><br>  *key = __key &gt;&gt; __shift;<br>  *mask = __mask &gt;&gt; __shift;<br>  *shift = __shift;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到了特定指令的匹配规律，我们就可以对取到的指令进行逐一匹配了。<br></p><h3 id="3-2-指令匹配过程"><a href="#3-2-指令匹配过程" class="headerlink" title="3.2 指令匹配过程"></a>3.2 指令匹配过程</h3><p><code>if ((((uint64_t)INSTPAT_INST(s) &gt;&gt; shift) &amp; mask) == key) &#123; \</code>这条if语句对取到的指令进行匹配,<br><br>如符合，则执行<code>INSTPAT_MATCH(s, ##__VA_ARGS__); \</code>。<br><br>这个宏在decode_exec中定义。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSTPAT_MATCH(s, name, type, ... <span class="hljs-comment">/* execute body */</span> ) &#123; \</span><br><span class="hljs-meta">  int rd = 0; \</span><br><span class="hljs-meta">  word_t src1 = 0, src2 = 0, imm = 0; \</span><br><span class="hljs-meta">  decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, concat(TYPE_, type)); \</span><br><span class="hljs-meta">  __VA_ARGS__ ; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-立即数译码过程"><a href="#3-3-立即数译码过程" class="headerlink" title="3.3 立即数译码过程"></a>3.3 立即数译码过程</h3><p>这里的decode_operand用来对立即数进行译码。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  TYPE_I, TYPE_U, TYPE_S,<br>  TYPE_N, <span class="hljs-comment">// none</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> src1R() do &#123; *src1 = R(rs1); &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> src2R() do &#123; *src2 = R(rs2); &#125; while (0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immI() do &#123; *imm = SEXT(BITS(i, 31, 20), 12); &#125; while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immU() do &#123; *imm = SEXT(BITS(i, 31, 12), 20) &lt;&lt; 12; &#125; while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> immS() do &#123; *imm = (SEXT(BITS(i, 31, 25), 7) &lt;&lt; 5) | BITS(i, 11, 7); &#125; while(0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">decode_operand</span><span class="hljs-params">(Decode *s, <span class="hljs-type">int</span> *rd, <span class="hljs-type">word_t</span> *src1, <span class="hljs-type">word_t</span> *src2, <span class="hljs-type">word_t</span> *imm, <span class="hljs-type">int</span> type)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> i = s-&gt;isa.inst;<br>  <span class="hljs-type">int</span> rs1 = BITS(i, <span class="hljs-number">19</span>, <span class="hljs-number">15</span>);<br>  <span class="hljs-type">int</span> rs2 = BITS(i, <span class="hljs-number">24</span>, <span class="hljs-number">20</span>);<br>  *rd     = BITS(i, <span class="hljs-number">11</span>, <span class="hljs-number">7</span>);<br>  <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-keyword">case</span> TYPE_I: src1R();          immI(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_U:                   immU(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_S: src1R(); src2R(); immS(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TYPE_N: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: panic(<span class="hljs-string">&quot;unsupported type = %d&quot;</span>, type);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中存在五个辅助宏，用于便捷的获取立即数。<br></p><h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4 执行"></a>4 执行</h2><p>程序执行<code>INSTPAT(&quot;??????? ????? ????? ??? ????? 00101 11&quot;, auipc  , U, R(rd) = s-&gt;pc + imm);</code><br><br>中的<code>R(rd) = s-&gt;pc + imm</code>指令。指令执行的阶段结束之后, decode_exec()函数将会返回0, 并一路返回到exec_once()函数中。<br></p><h2 id="5-更新PC"><a href="#5-更新PC" class="headerlink" title="5 更新PC"></a>5 更新PC</h2><p>上文已经提到snpc与dnpc的区别，在程序执行时我们需要正确维护dnpc。<br><br><code>cpu.pc = s-&gt;dnpc;</code>来更新dnpc。<br></p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2.3-程序如何在AM上运行</title>
    <link href="/2025/02/26/PA2-3-%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%9C%A8AM%E4%B8%8A%E8%BF%90%E8%A1%8C/"/>
    <url>/2025/02/26/PA2-3-%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%9C%A8AM%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>对整个计算机系统(NEMU,ISA,AM,运行时环境,程序)相互联系的个人理解.</p><span id="more"></span><p>本文章为一生一芯教学项目的个人理解,笔者并不能保证其正确,请注意<strong>学术诚信</strong><br>笔者并非计算机科班,内容难免存在错误,如您发现,欢迎与我联系.</p><h2 id="计算机是个抽象层-程序如何在计算机上运行"><a href="#计算机是个抽象层-程序如何在计算机上运行" class="headerlink" title="计算机是个抽象层:程序如何在计算机上运行"></a>计算机是个抽象层:程序如何在计算机上运行</h2><ul><li>AM为程序提供了运行时环境.</li><li>AM将NEMU的接口做了一层抽象,NEMU是底层的硬件模拟层(处理指令执行、设备交互),而AM在此之上构建软件抽象层.</li><li>AM和NEMU的运行依赖于宿主环境的运行时环境.</li></ul><h3 id="NEMU与AM如何协同工作"><a href="#NEMU与AM如何协同工作" class="headerlink" title="NEMU与AM如何协同工作"></a>NEMU与AM如何协同工作</h3><p>NEMU中进行注册内存映射操作,将一块内存映射到NEMU的端口中(MMIO),并设定回调函数,当有对这块内存读写操作时就调用回调函数.在回调函数中使用C语言的API更新对应设备.<br>AM中对内存进行读写,间接的操控设备.</p><h3 id="AM-运行时环境-程序如何协同工作"><a href="#AM-运行时环境-程序如何协同工作" class="headerlink" title="AM,运行时环境,程序如何协同工作"></a>AM,运行时环境,程序如何协同工作</h3><p>AM为程序提供了运行时环境,程序通过调用AM提供的IOE接口访问AM中的抽象寄存器并触发回调函数,而AM通过读取抽象寄存器的值对MMIO进行读写.以这种方法程序间接实现对MMIO的读写,控制设备.</p><h2 id="程序是个状态机-游戏是如何运行的"><a href="#程序是个状态机-游戏是如何运行的" class="headerlink" title="程序是个状态机:游戏是如何运行的"></a>程序是个状态机:游戏是如何运行的</h2><ul><li>初始化:ioe_init初始化IOE,video_init初始化VGA,读取timer的初始值</li><li>获取游戏运行时间(时钟)</li><li>更新游戏逻辑(TRM)</li><li>读取键盘按键(键盘):NONE-&gt;下一个状态,Esc-&gt;halt,按键-&gt;检查是否命中-&gt;下一个状态</li><li>刷新页面(VGA)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>一生一芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
